--- a/filter/gstoraster.c
+++ b/filter/gstoraster.c
@@ -795,6 +795,15 @@
     cupsArrayAdd(gs_args, strdup("-dColorConversionStrategy=/LeaveColorUnchanged"));
   }
   
+#ifdef HAVE_CUPS_1_7
+  if (outformat == OUTPUT_FORMAT_RASTER)
+  {
+    t = getenv("FINAL_CONTENT_TYPE");
+    if (t && strcasestr(t, "pwg"))
+      pwgraster = 1;
+  }
+#endif /* HAVE_CUPS_1_7 */
+    
   if (ppd)
   {
     cupsRasterInterpretPPD(&h,ppd,num_options,options,0);
@@ -805,10 +814,9 @@
 	  (!strcasecmp(attr->value, "true") ||
 	   !strcasecmp(attr->value, "on") ||
 	   !strcasecmp(attr->value, "yes")))
-      {
 	pwgraster = 1;
+      if (pwgraster == 1)
 	cupsRasterParseIPPOptions(&h, num_options, options, pwgraster, 0);
-      }
     }
 #endif /* HAVE_CUPS_1_7 */
     if (outformat == OUTPUT_FORMAT_PXL)
--- a/filter/pdftopdf/pdftopdf.cc
+++ b/filter/pdftopdf/pdftopdf.cc
@@ -601,7 +601,9 @@
   // The filters currently are:
   // - foomatic-rip (lets Ghostscript convert PDF to printer's format via
   //   built-in drivers, no access to the PDF content)
-  // - gstopxl (simple script filter)
+  // - gstopxl (uses Ghostscript, like foomatic-rip)
+  // - *toraster on IPP Everywhere printers (then *toraster gets the last
+  //   filter, the case if FINAL_CONTENT_TYPE env var is "image/pwg-raster")
   // - hpps (bug)
 
   // Check whether page logging is forced or suppressed by the command line
@@ -644,7 +646,7 @@
       // Proceed depending on number of cupsFilter(2) lines in PPD
       } else if (ppd->num_filters == 0) {
 	// No filter line, manufacturer-supplied PostScript PPD
-	// In this case pstops, called by pdftops does the logging
+	// In this case pstops, called by pdftops, does the logging
 	param.page_logging = 0;
       } else if (ppd->num_filters == 1) {
 	// One filter line, so this one filter is the last filter
@@ -690,11 +692,14 @@
 	  lastfilter = q + 1;
 	  // Check whether we have to log
 	  if (!strcasecmp(lastfilter, "-")) {
-	    // No filter defined in the PPD, if incoming data
-	    // (FINAL_CONTENT_TYPE) is PDF, pdftopdf is last filter
-	    // (PDF printer) and has to log
+	    // No filter defined in the PPD
+	    // If output data (FINAL_CONTENT_TYPE) is PDF, pdftopdf is last
+	    // filter (PDF printer) and has to log
+	    // If output data (FINAL_CONTENT_TYPE) is PWG Raster, *toraster is
+	    // last filter (IPP Everywhere printer) and pdftopdf has to log
 	    if (strcasestr(final_content_type, "/pdf") ||
-		strcasestr(final_content_type, "/vnd.cups-pdf"))
+		strcasestr(final_content_type, "/vnd.cups-pdf") ||
+		strcasestr(final_content_type, "/pwg-raster"))
 	      param.page_logging = 1;
 	    else
 	      param.page_logging = 0;
@@ -702,9 +707,16 @@
 	    // pdftopdf is last filter (PDF printer)
 	    param.page_logging = 1;
 	  } else if (!strcasecmp(lastfilter, "gstopxl")) {
-	    // gstopxl is last filter, this is a simple script without
-	    // access to the pages of the file to be printed, so we log the
-	    // pages
+	    // gstopxl is last filter, this is a Ghostscript-based filter
+	    // without access to the pages of the file to be printed, so we
+	    // log the pages
+	    param.page_logging = 1;
+	  } else if (!strcasecmp(lastfilter + strlen(lastfilter) - 8,
+				 "toraster")) {
+	    // On IPP Everywhere printers which accept PWG Raster data one
+	    // of gstoraster, pdftoraster, or mupdftoraster is the last
+	    // filter. These filters do not log pages so pdftopdf has to
+	    // do it
 	    param.page_logging = 1;
 	  } else if (!strcasecmp(lastfilter, "foomatic-rip")) {
 	    // foomatic-rip is last filter, foomatic-rip is mainly used as
--- a/filter/pdftoraster.cxx
+++ b/filter/pdftoraster.cxx
@@ -267,7 +267,6 @@
     cmsHPROFILE sgray;
 
     cmsCIExyY wp;
-    cmsCIExyYTRIPLE primaries;
 
 #if USE_LCMS1
     cmsToneCurve Gamma = cmsBuildGamma(256, 2.2);
@@ -460,7 +459,8 @@
   int num_options = 0;
   cups_option_t *options = 0;
   GooString profilePath;
-  char * profile = 0;
+  char *profile = 0;
+  const char *t = NULL;
   ppd_attr_t *attr;
 
   if (argc < 6 || argc > 7) {
@@ -469,6 +469,12 @@
     exit(1);
   }
 
+#ifdef HAVE_CUPS_1_7
+  t = getenv("FINAL_CONTENT_TYPE");
+  if (t && strcasestr(t, "pwg"))
+    pwgraster = 1;
+#endif /* HAVE_CUPS_1_7 */
+    
   ppd = ppdOpenFile(getenv("PPD"));
   if (ppd == NULL)
     fprintf(stderr, "DEBUG: PPD file is not specified.\n");
@@ -560,15 +566,14 @@
 	(!strcasecmp(attr->value, "true")
 	 || !strcasecmp(attr->value, "on") ||
 	 !strcasecmp(attr->value, "yes")))
-    {
       pwgraster = 1;
+    if (pwgraster == 1)
       cupsRasterParseIPPOptions(&header, num_options, options, pwgraster, 0);
-    }
 #endif /* HAVE_CUPS_1_7 */
   } else {
 #ifdef HAVE_CUPS_1_7
     pwgraster = 1;
-    const char *t = cupsGetOption("media-class", num_options, options);
+    t = cupsGetOption("media-class", num_options, options);
     if (t == NULL)
       t = cupsGetOption("MediaClass", num_options, options);
     if (t != NULL)
@@ -1724,10 +1729,12 @@
       landscape = 0;
       paperdimensions[0] = size->width;
       paperdimensions[1] = size->length;
-      margins[0] = size->left;
-      margins[1] = size->bottom;
-      margins[2] = size->width - size->right;
-      margins[3] = size->length - size->top;
+      if (pwgraster == 0) {
+	margins[0] = size->left;
+	margins[1] = size->bottom;
+	margins[2] = size->width - size->right;
+	margins[3] = size->length - size->top;
+      }
       strncpy(header.cupsPageSizeName, size->name, 64);
     } else {
       /*
@@ -1750,10 +1757,12 @@
 	landscape = 1;
 	paperdimensions[0] = size->width;
 	paperdimensions[1] = size->length;
-	margins[0] = size->left;
-	margins[1] = size->bottom;
-	margins[2] = size->width - size->right;
-	margins[3] = size->length - size->top;
+	if (pwgraster == 0) {
+	  margins[0] = size->left;
+	  margins[1] = size->bottom;
+	  margins[2] = size->width - size->right;
+	  margins[3] = size->length - size->top;
+	}
 	strncpy(header.cupsPageSizeName, size->name, 64);
       } else {
 	/*
@@ -1764,8 +1773,9 @@
 	paperdimensions[1] = size->length;
 	for (i = 0; i < 2; i ++)
 	  paperdimensions[i] = header.PageSize[i];
-	for (i = 0; i < 4; i ++)
-	  margins[i] = ppd->custom_margins[i];
+	if (pwgraster == 0)
+	  for (i = 0; i < 4; i ++)
+	    margins[i] = ppd->custom_margins[i];
 	header.cupsPageSizeName[0] = '\0';
       }
     }
@@ -1774,10 +1784,12 @@
       paperdimensions[i] = header.PageSize[i];
     if (header.cupsImagingBBox[3] > 0.0) {
       /* Set margins if we have a bounding box defined ... */
-      margins[0] = header.cupsImagingBBox[0];
-      margins[1] = header.cupsImagingBBox[1];
-      margins[2] = paperdimensions[0] - header.cupsImagingBBox[2];
-      margins[3] = paperdimensions[1] - header.cupsImagingBBox[3];
+      if (pwgraster == 0) {
+	margins[0] = header.cupsImagingBBox[0];
+	margins[1] = header.cupsImagingBBox[1];
+	margins[2] = paperdimensions[0] - header.cupsImagingBBox[2];
+	margins[3] = paperdimensions[1] - header.cupsImagingBBox[3];
+      }
     } else
       /* ... otherwise use zero margins */
       for (i = 0; i < 4; i ++)
@@ -1806,19 +1818,26 @@
   bitmapoffset[1] = margins[3] / 72.0 * header.HWResolution[1];
 
   /* write page header */
-  header.cupsWidth = ((paperdimensions[0] - margins[0] - margins[2]) /
-		      72.0 * header.HWResolution[0]) + 0.5;
-  header.cupsHeight = ((paperdimensions[1] - margins[1] - margins[3]) /
-		       72.0 * header.HWResolution[1] + 0.5);
+  if (pwgraster == 0) {
+    header.cupsWidth = ((paperdimensions[0] - margins[0] - margins[2]) /
+			72.0 * header.HWResolution[0]) + 0.5;
+    header.cupsHeight = ((paperdimensions[1] - margins[1] - margins[3]) /
+			 72.0 * header.HWResolution[1]) + 0.5;
+  } else {
+    header.cupsWidth = (paperdimensions[0] /
+			72.0 * header.HWResolution[0]) + 0.5;
+    header.cupsHeight = (paperdimensions[1] /
+			 72.0 * header.HWResolution[1]) + 0.5;
+  }
   for (i = 0; i < 2; i ++) {
     header.cupsPageSize[i] = paperdimensions[i];
     header.PageSize[i] = (unsigned int)(header.cupsPageSize[i] + 0.5);
-    if (strcasecmp(header.MediaClass, "PwgRaster") != 0)
+    if (pwgraster == 0)
       header.Margins[i] = margins[i] + 0.5;
     else
       header.Margins[i] = 0;
   }
-  if (strcasecmp(header.MediaClass, "PwgRaster") != 0) {
+  if (pwgraster == 0) {
     header.cupsImagingBBox[0] = margins[0];
     header.cupsImagingBBox[1] = margins[1];
     header.cupsImagingBBox[2] = paperdimensions[0] - margins[2];
--- a/mime/cupsfilters-ghostscript.convs
+++ b/mime/cupsfilters-ghostscript.convs
@@ -17,4 +17,5 @@
 
 application/postscript		application/pdf			0	gstopdf
 application/vnd.cups-pdf	application/vnd.cups-raster	99	gstoraster
+application/vnd.cups-pdf	image/pwg-raster		99	gstoraster
 application/vnd.cups-postscript	application/vnd.cups-raster	175	gstoraster
--- a/mime/cupsfilters-poppler.convs
+++ b/mime/cupsfilters-poppler.convs
@@ -16,3 +16,4 @@
 #
 
 application/vnd.cups-pdf	application/vnd.cups-raster	100	pdftoraster
+application/vnd.cups-pdf	image/pwg-raster		100	pdftoraster
--- a/utils/cups-browsed.c
+++ b/utils/cups-browsed.c
@@ -268,6 +268,14 @@
   IP_BASED_URIS_IPV6_ONLY
 } ip_based_uris_t;
 
+/* Automatically create queues for IPP network printers: No, only for
+   IPP printers, for all printers */
+typedef enum create_ipp_printer_queues_e {
+  IPP_PRINTERS_NO,
+  IPP_PRINTERS_EVERYWHERE,
+  IPP_PRINTERS_ALL
+} create_ipp_printer_queues_t;
+
 /* Ways how to set up a queue for an IPP network printer */
 typedef enum ipp_queue_type_e {
   PPD_YES,
@@ -341,7 +349,7 @@
 static char *DomainSocket = NULL;
 static ip_based_uris_t IPBasedDeviceURIs = IP_BASED_URIS_NO;
 static unsigned int CreateRemoteRawPrinterQueues = 0;
-static unsigned int CreateIPPPrinterQueues = 0;
+static create_ipp_printer_queues_t CreateIPPPrinterQueues = IPP_PRINTERS_NO;
 static ipp_queue_type_t IPPPrinterQueueType = PPD_YES;
 static load_balancing_type_t LoadBalancingType = QUEUE_ON_CLIENT;
 static const char *DefaultOptions = NULL;
@@ -3019,7 +3027,7 @@
        from mobile devices, even if there is no CUPS server with
        shared printers around. */
 
-    if (CreateIPPPrinterQueues == 0) {
+    if (CreateIPPPrinterQueues == IPP_PRINTERS_NO) {
       debug_printf("Printer %s (%s) is an IPP network printer and cups-browsed is not configured to set up such printers automatically, ignoring this printer.\n",
 		   p->name, p->uri);
       goto fail;
@@ -3085,6 +3093,36 @@
       }
     }
 
+    /* If we have opted for only IPP Everywhere printers being set up
+       automatically, we check whether the printer has the "ipp-everywhere"
+       keyword in its "ipp-features-supported" IPP attribute. If the keyword
+       or the attribute is not present, we skip this printer. */
+    if (CreateIPPPrinterQueues == IPP_PRINTERS_EVERYWHERE) {
+      valuebuffer[0] = '\0';
+      if ((attr = ippFindAttribute(response, "ipp-features-supported", IPP_TAG_KEYWORD)) != NULL) {
+	debug_printf("Checking whether printer %s is IPP Everywhere: Attr: %s\n",
+		     p->name, ippGetName(attr));
+	ippAttributeString(attr, valuebuffer, sizeof(valuebuffer));
+	debug_printf("Checking whether printer %s is IPP Everywhere: Value: %s\n",
+		     p->name, valuebuffer);
+	if (strcasecmp(valuebuffer, "ipp-everywhere")) {
+	  for (i = 0; i < ippGetCount(attr); i ++) {
+	    strncpy(valuebuffer, ippGetString(attr, i, NULL),
+		    sizeof(valuebuffer));
+	    debug_printf("Checking whether printer %s is IPP Everywhere: Keyword: %s\n",
+			 p->name, valuebuffer);
+	    if (!strcasecmp(valuebuffer, "ipp-everywhere"))
+	      break;
+	  }
+	}
+      }
+      if (!attr || strcasecmp(valuebuffer, "ipp-everywhere")) {
+	debug_printf("Printer %s (%s) is not an IPP Everywhere printer and cups-browsed is not configured to set up such printers automatically, ignoring this printer.\n",
+		   p->name, p->uri);
+	goto fail;
+      }
+    }
+
     if (IPPPrinterQueueType == PPD_YES) {
       if (!_ppdCreateFromIPP(buffer, sizeof(buffer), response, make_model,
 			     pdl, color, duplex)) {
@@ -6286,12 +6324,15 @@
 	  !strcasecmp(value, "off") || !strcasecmp(value, "0"))
 	CreateRemoteRawPrinterQueues = 0;
     } else if (!strcasecmp(line, "CreateIPPPrinterQueues") && value) {
-      if (!strcasecmp(value, "yes") || !strcasecmp(value, "true") ||
+      if (!strcasecmp(value, "all") ||
+	  !strcasecmp(value, "yes") || !strcasecmp(value, "true") ||
 	  !strcasecmp(value, "on") || !strcasecmp(value, "1"))
-	CreateIPPPrinterQueues = 1;
+	CreateIPPPrinterQueues = IPP_PRINTERS_ALL;
       else if (!strcasecmp(value, "no") || !strcasecmp(value, "false") ||
 	  !strcasecmp(value, "off") || !strcasecmp(value, "0"))
-	CreateIPPPrinterQueues = 0;
+	CreateIPPPrinterQueues = IPP_PRINTERS_NO;
+      else if (strcasestr(value, "every"))
+	CreateIPPPrinterQueues = IPP_PRINTERS_EVERYWHERE;
     } else if (!strcasecmp(line, "IPPPrinterQueueType") && value) {
       if (!strncasecmp(value, "Auto", 4))
 	IPPPrinterQueueType = PPD_YES;
--- a/utils/cups-browsed.conf.5
+++ b/utils/cups-browsed.conf.5
@@ -450,22 +450,38 @@
 
 .fam T
 .fi
-The CreateIPPPrinterQueues directive specifies whether cups-browsed
-should discover IPP printers (via Bonjour) and if they understand a
-known page description language (PWG Raster, PDF, PostScript, PCL XL,
-PCL 5c/e) create PPD-less print queues (using a System V interface
-script to control the filter chain). Clients have to IPP-poll the
-capabilities of the printer and send option settings as standard IPP
-attributes. We do not poll the capabilities by ourselves to not wake
-up the printer from power-saving mode when creating the queues. Jobs
-have to be sent in one of PDF, PWG Raster, or JPEG format. Other
-formats are not accepted. This functionality is primarily for mobile
-devices running CUPS to not need a printer setup tool nor a collection
-of printer drivers and PPDs.
+Set CreateIPPPrinterQueues to "All" to let cups-browsed discover IPP
+network printers (native printers, not CUPS queues) with known page
+description languages (PWG Raster, PDF, PostScript, PCL XL, PCL
+5c/e) in the local network and auto-create print queues for them.
+
+Set CreateIPPPrinterQueues to "Everywhere" to let cups-browsed
+discover IPP Everywhere printers in the local network (native
+printers, not CUPS queues) and auto-create print queues for them.
+
+If queues with PPD file are created (see IPPPrinterQueueType
+directive below) the PPDs are auto-generated by cups-browsed based
+on properties of the printer polled via IPP. In case of missing
+information, info from the Bonjour record is used asd as last mean
+default values.
+
+If queues without PPD (see IPPPrinterQueueType directive below) are
+created clients have to IPP-poll the capabilities of the printer and
+send option settings as standard IPP attributes. We do not poll the
+capabilities by ourselves to not wake up the printer from
+power-saving mode when creating the queues. Jobs have to be sent in
+one of PDF, PWG Raster, or JPEG format. Other formats are not
+accepted.
+
+This functionality is primarily for mobile devices running
+CUPS to not need a printer setup tool nor a collection of printer
+drivers and PPDs.
 .PP
 .nf
 .fam C
-        CreateIPPPrinterQueues Yes
+        CreateIPPPrinterQueues No
+        CreateIPPPrinterQueues Everywhere
+        CreateIPPPrinterQueues All
 
 .fam T
 .fi
--- a/utils/cups-browsed.conf.in
+++ b/utils/cups-browsed.conf.in
@@ -314,21 +314,36 @@
 # CreateRemoteRawPrinterQueues Yes
 
 
-# Set CreateIPPPrinterQueues to "Yes" to let cups-browsed discover IPP
+# Set CreateIPPPrinterQueues to "All" to let cups-browsed discover IPP
 # network printers (native printers, not CUPS queues) with known page
 # description languages (PWG Raster, PDF, PostScript, PCL XL, PCL
-# 5c/e) in the local network and auto-create PPD-less print queues for
-# them (using a System V interface script to control the filter
-# chain). Clients have to IPP-poll the capabilities of the printer and
+# 5c/e) in the local network and auto-create print queues for them.
+
+# Set CreateIPPPrinterQueues to "Everywhere" to let cups-browsed
+# discover IPP Everywhere printers in the local network (native
+# printers, not CUPS queues) and auto-create print queues for them.
+
+# If queues with PPD file are created (see IPPPrinterQueueType
+# directive below) the PPDs are auto-generated by cups-browsed based
+# on properties of the printer polled via IPP. In case of missing
+# information, info from the Bonjour record is used asd as last mean
+# default values.
+
+# If queues without PPD (see IPPPrinterQueueType directive below) are
+# created clients have to IPP-poll the capabilities of the printer and
 # send option settings as standard IPP attributes. We do not poll the
 # capabilities by ourselves to not wake up the printer from
 # power-saving mode when creating the queues. Jobs have to be sent in
 # one of PDF, PWG Raster, or JPEG format. Other formats are not
-# accepted. This functionality is primarily for mobile devices running
+# accepted.
+
+# This functionality is primarily for mobile devices running
 # CUPS to not need a printer setup tool nor a collection of printer
 # drivers and PPDs.
 
-# CreateIPPPrinterQueues Yes
+# CreateIPPPrinterQueues No
+CreateIPPPrinterQueues Everywhere
+# CreateIPPPrinterQueues All
 
 
 # If cups-browsed is automatically creating print queues for native
